/*
 * Auto-generated by Frida. Please modify to match the signature of EVP_KDF_derive.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
  /**
   * Called synchronously when about to call EVP_KDF_derive.
   *
   * @this {object} - Object allowing you to store state for use in onLeave.
   * @param {function} log - Call this function with a string to be presented to the user.
   * @param {array} args - Function arguments represented as an array of NativePointer objects.
   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.
   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
   * @param {object} state - Object allowing you to keep state across function calls.
   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
   * However, do not use this to store function arguments across onEnter/onLeave, but instead
   * use "this" which is an object for keeping state local to an invocation.
   */
  onEnter(log, args, state) {
    console.log('EVP_KDF_derive() intercepted onEnter.');
    
    this.params = args[3];

    if(!state.params) {
      state.params = []; // (void *)
      state.salt = [];
    }

    state.rule4_violated = -1;
    state.rule5_violated = -1;
  },

  /**
   * Called synchronously when about to return from EVP_KDF_derive.
   *
   * See onEnter for details.
   *
   * @this {object} - Object allowing you to access state stored in onEnter.
   * @param {function} log - Call this function with a string to be presented to the user.
   * @param {NativePointer} retval - Return value represented as a NativePointer object.
   * @param {object} state - Object allowing you to keep state across function calls.
   */
  onLeave(log, retval, state) {
    // console.log('EVP_KDF_derive() intercepted onLeave.');

    paramElementOffset = 40;
    keyOffset = 0;
    dataTypeOffset = 8;
    dataOffset = 16;
    dataSizeOffset = 24;

    if(this.params == 0) {
      // console.log('params is null. returning.');
      return;
    }

    currentOffset = 0;
    salt = NULL;
    saltLen = 0;
    iter = -1;

    while(!(this.params.readPointer().readUtf8String() == null)) {
      if(this.params.readPointer().readUtf8String() === "salt") {
        saltLen = this.params.add(dataSizeOffset).readPointer().toInt32();
        if(saltLen > 0) {
          salt = new Uint8Array(this.params.add(dataOffset).readPointer().readByteArray(saltLen));
        }
      } else if(this.params.readPointer().readUtf8String() === "iter") {
        iter = this.params.add(dataOffset).readPointer().readPointer().toInt32();
      }
           
      this.params = this.params.add(paramElementOffset);
    }
   
    saltIsEqual = false;

    state.salt.forEach((saltElement, index) => {
        var saltIsEqual = false;

        for(let i = 0; i < saltElement.length && saltElement.length === salt.length; i++) {
          saltIsEqual = saltElement[i] === salt[i];
        }
        
        if(saltIsEqual) {
          state.rule4_violated = index;
        }
    });
    
    if(state.rule4_violated >= 0) {
      console.warn("--- VIOLATION of Rule 4: Do not use constant salts for PBE. ---");
    }

    if(iter >= 0 && iter < 1000) {
      console.warn("KDF_derive called with insufficient iteration count: " + iter);
      console.warn("--- VIOLATION of Rule 5: Do not use fewer than 1,000 iterations for PBE. ---");
    }

    if(salt != NULL) {
      state.salt.push(salt);
    }
  }
}
