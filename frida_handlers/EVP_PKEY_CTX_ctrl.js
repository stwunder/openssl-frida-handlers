/*
 * Auto-generated by Frida. Please modify to match the signature of EVP_PKEY_CTX_ctrl.
 * This stub is currently auto-generated from manpages when available.
 *
 * For full API reference, see: https://frida.re/docs/javascript-api/
 */

{
  /**
   * Called synchronously when about to call EVP_PKEY_CTX_ctrl.
   *
   * @this {object} - Object allowing you to store state for use in onLeave.
   * @param {function} log - Call this function with a string to be presented to the user.
   * @param {array} args - Function arguments represented as an array of NativePointer objects.
   * For example use args[0].readUtf8String() if the first argument is a pointer to a C string encoded as UTF-8.
   * It is also possible to modify arguments by assigning a NativePointer object to an element of this array.
   * @param {object} state - Object allowing you to keep state across function calls.
   * Only one JavaScript function will execute at a time, so do not worry about race-conditions.
   * However, do not use this to store function arguments across onEnter/onLeave, but instead
   * use "this" which is an object for keeping state local to an invocation.
   */
  onEnter(log, args, state) {
    console.log('EVP_PKEY_CTX_ctrl() intercepted onEnter.');
    
    this.ctx = args[0];
    this.salt = args[5];
    this.saltLen = args[4];
    this.cmd = args[3];

    if(typeof state.ctx === 'undefined') {
      state.ctx = []; // (void *)
    } 

    if(typeof state.salt === 'undefined') {
      state.salt = []; // (void *)
    }

    if(typeof state.saltLen === 'undefined') {
      state.saltLen = []; // int
    }

    if(typeof state.cmd === 'undefined') {
      state.cmd = []; // int
    }

    state.rule4_violated = -1;

    // console.log(
    //   'args[0]: ' + args[0] 
    // + '\nargs[1]: ' + args[1]
    // + '\nargs[2]: ' + args[2] 
    // + '\nargs[3]: ' + args[3] 
    // + '\nargs[4]: ' + args[4] 
    // + '\nargs[5]: ' + args[5]
    // );
  },

  /**
   * Called synchronously when about to return from EVP_PKEY_CTX_ctrl.
   *
   * See onEnter for details.
   *
   * @this {object} - Object allowing you to access state stored in onEnter.
   * @param {function} log - Call this function with a string to be presented to the user.
   * @param {NativePointer} retval - Return value represented as a NativePointer object.
   * @param {object} state - Object allowing you to keep state across function calls.
   */
  onLeave(log, retval, state) {
    // console.log('EVP_PKEY_CTX_ctrl() intercepted onLeave.');  

    const EVP_PKEY_CTRL_TLS_SECRET = 4098; // HEX: 0x1002
    const EVP_PKEY_CTRL_HKDF_SALT = 4100; // HEX: 0x1004
    const EVP_PKEY_CTRL_SCRYPT_SALT = 4105;  // HEX: 0x1009

    if(this.cmd.toInt32() === EVP_PKEY_CTRL_TLS_SECRET || 
      this.cmd.toInt32() === EVP_PKEY_CTRL_HKDF_SALT || 
      this.cmd.toInt32() === EVP_PKEY_CTRL_SCRYPT_SALT) { 

      state.salt.forEach(saltElement => {
        // console.log('ctxElement: ' + ctxElement);

        var currentSalt = new Uint8Array(this.salt.readByteArray(this.saltLen.toInt32()));
        
        // console.log('currentSalt.length: ' + currentSalt.length);
        // console.log('state.cmd[index]: ' + state.cmd[index] + ' this.cmd.toInt32(): ' + this.cmd.toInt32());

        if(state.cmd[index] === this.cmd.toInt32()) {
          
          var saltIsEqual = false;

          if(currentSalt.length === 0 && saltElement.length === 0) {
            saltIsEqual = true;
          } else {
            for(let i = 0; i < saltElement.length && currentSalt.length > 0 && saltElement.length === currentSalt.length; i++) {
              saltIsEqual = saltElement[i] === currentSalt[i];
            }
          }
  
          if(saltIsEqual) {
            if(this.cmd.toInt32() === EVP_PKEY_CTRL_TLS_SECRET) {
              state.rule6_violated = index;
              // console.log('rule 6 violated at seed element with index: ' + state.rule6_violated);
            } else {
              state.rule4_violated = index;
              // console.log('rule 4 violated at salt element with index: ' + state.rule4_violated);
            }            
          }
        }
      });
    }

    if(this.cmd.toInt32() === EVP_PKEY_CTRL_TLS_SECRET || this.cmd.toInt32() === EVP_PKEY_CTRL_HKDF_SALT || this.cmd.toInt32() === EVP_PKEY_CTRL_SCRYPT_SALT) { 
      state.ctx.push(this.ctx.toInt32());
      state.salt.push(new Uint8Array(this.salt.readByteArray(this.saltLen.toInt32())));
      state.saltLen.push(this.saltLen.toInt32());
      state.cmd.push(this.cmd.toInt32());
    } 

    // state.ctx.forEach(e => {
    //   // console.log('ctx: ' + e);
    // });

    // state.salt.forEach(e => {
    //   // console.log('salt/seed: ' + e);
    // });

    // state.saltLen.forEach(e => {
    //   // console.log('saltLen/seedLen: ' + e);
    // });

    // state.cmd.forEach(e => {
    //   // console.log('cmd: ' + e);
    // });

    if(state.rule4_violated >= 0 && (this.cmd.toInt32() === EVP_PKEY_CTRL_HKDF_SALT || this.cmd.toInt32() === EVP_PKEY_CTRL_SCRYPT_SALT)) {
      console.warn("EVP_PKEY_CTX_ctrl called with constant salt: " + currentSalt);
      console.warn("--- VIOLATION of Rule 4: Do not use constant salts for PBE. ---");
    }

    if(state.rule6_violated >= 0 && this.cmd.toInt32() === EVP_PKEY_CTRL_TLS_SECRET) {
      console.warn("--- VIOLATION of Rule 6: Do not use static seeds to initialize secure random generator. ---");
    }
  }
}
